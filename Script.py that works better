#!/usr/bin/env python3
"""
â–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â•
â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â• â•šâ•â•â•šâ•â• â•šâ•â•â•šâ•â• â•šâ•â• â•šâ•â• â•šâ•â•â•â•â•â•â•
                                                               
NETWORK SECURITY SCANNER & AUTO-PATCHER V3.0
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Scans vulnerabilities | ğŸ” Detects intruders | ğŸ›¡ï¸ Auto-patches
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Usage: chmod +x ultimate_security.py && sudo ./ultimate_security.py
"""
import socket
import sys
import os
import subprocess
import re
import time
import hashlib
import json
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import defaultdict

# Color codes for cool terminal output
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def is_root():
    return os.geteuid() == 0

# Comprehensive port database with risk analysis
PORT_DATABASE = {
    21: {"service": "FTP", "risk": "HIGH", "necessary": False, "reason": "Unencrypted file transfer", "services": ["vsftpd", "proftpd"], "cve": "CVE-2024-XXXX"},
    22: {"service": "SSH", "risk": "LOW", "necessary": True, "reason": "Secure shell access", "services": ["sshd"], "cve": None},
    23: {"service": "Telnet", "risk": "CRITICAL", "necessary": False, "reason": "No encryption - passwords visible", "services": ["telnetd"], "cve": "CVE-2023-XXXX"},
    25: {"service": "SMTP", "risk": "MEDIUM", "necessary": False, "reason": "Mail server", "services": ["postfix", "sendmail"], "cve": None},
    80: {"service": "HTTP", "risk": "MEDIUM", "necessary": False, "reason": "Unencrypted web traffic", "services": ["apache2", "nginx", "httpd"], "cve": None},
    443: {"service": "HTTPS", "risk": "LOW", "necessary": False, "reason": "Encrypted web traffic", "services": ["apache2", "nginx"], "cve": None},
    445: {"service": "SMB", "risk": "HIGH", "necessary": False, "reason": "File sharing - ransomware vector", "services": ["smbd"], "cve": "CVE-2024-SMB"},
    3306: {"service": "MySQL", "risk": "CRITICAL", "necessary": False, "reason": "Database exposed - data breach risk", "services": ["mysql", "mysqld", "mariadb"], "cve": "CVE-2024-MYSQL"},
    3389: {"service": "RDP", "risk": "CRITICAL", "necessary": False, "reason": "Remote Desktop - brute force target", "services": ["xrdp"], "cve": "CVE-2024-RDP"},
    5432: {"service": "PostgreSQL", "risk": "HIGH", "necessary": False, "reason": "Database exposed", "services": ["postgresql"], "cve": None},
    5900: {"service": "VNC", "risk": "HIGH", "necessary": False, "reason": "Remote desktop - weak encryption", "services": ["vncserver", "x11vnc"], "cve": None},
    6379: {"service": "Redis", "risk": "CRITICAL", "necessary": False, "reason": "No authentication by default", "services": ["redis-server"], "cve": "CVE-2024-REDIS"},
    27017: {"service": "MongoDB", "risk": "CRITICAL", "necessary": False, "reason": "NoSQL database - often unprotected", "services": ["mongod"], "cve": "CVE-2024-MONGO"}
}

class SecurityScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.patches_applied = []
        self.patches_failed = []
        self.suspicious_devices = []
        self.network_devices = []
        self.report_file = f"security_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        self.consent_given = {}
       
    def log_vulnerability(self, category, description, severity, affected_item):
        self.vulnerabilities.append({
            'category': category,
            'description': description,
            'severity': severity,
            'affected': affected_item,
            'timestamp': datetime.now().isoformat()
        })
   
    def log_patch(self, description, success, details=""):
        if success:
            self.patches_applied.append({'action': description, 'details': details, 'time': datetime.now().isoformat()})
        else:
            self.patches_failed.append({'action': description, 'details': details, 'time': datetime.now().isoformat()})
   
    def log_suspicious_device(self, ip, mac, reason, threat_level):
        self.suspicious_devices.append({
            'ip': ip,
            'mac': mac,
            'reason': reason,
            'threat_level': threat_level,
            'detected': datetime.now().isoformat()
        })

scanner = SecurityScanner()

def print_banner():
    os.system('clear' if os.name == 'posix' else 'cls')
    print(f"{Colors.OKCYAN}{Colors.BOLD}")
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘                                                                   â•‘")
    print("â•‘ â–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—          â•‘")
    print("â•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•          â•‘")
    print("â•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—          â•‘")
    print("â•‘ â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•          â•‘")
    print("â•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—          â•‘")
    print("â•‘  â•šâ•â•â•â•â•â•      â•šâ•â•   â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•     â•šâ•â•   â•šâ•â•â•â•â•â•â•          â•‘")
    print("â•‘                                                                   â•‘")
    print("â•‘               NETWORK SECURITY SCANNER & AUTO-PATCHER v3.0          â•‘")
    print("â•‘                                                                   â•‘")
    print("â•‘ âš¡ Vulnerability Scanning â”‚ ğŸ” Intrusion Detection                  â•‘")
    print("â•‘ ğŸ›¡ï¸ Auto-Patching         â”‚ ğŸ“Š Compliance Reporting                  â•‘")
    print("â•‘ ğŸŒ Network Mapping       â”‚ ğŸ‘¥ Suspicious Device Detection            â•‘")
    print("â•‘                                                                   â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"{Colors.ENDC}")

def run_command(command):
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=30)
        return result.returncode == 0, result.stdout, result.stderr
    except:
        return False, "", ""

def ask_permission(action, details="", severity="MEDIUM"):
    """Always asks for permission before any action"""
    severity_colors = {
        "LOW": Colors.OKGREEN,
        "MEDIUM": Colors.WARNING,
        "HIGH": Colors.FAIL,
        "CRITICAL": Colors.FAIL + Colors.BOLD
    }
   
    color = severity_colors.get(severity, Colors.WARNING)
   
    print(f"\n{color}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Colors.ENDC}")
    print(f"{color}â•‘ ğŸ” PERMISSION REQUEST - [{severity}] SEVERITY                     â•‘{Colors.ENDC}")
    print(f"{color}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.ENDC}")
    print(f"\n{Colors.BOLD}Action:{Colors.ENDC} {action}")
    if details:
        print(f"{Colors.BOLD}Details:{Colors.ENDC} {details}")
    print(f"\n{Colors.OKCYAN}This action will:{Colors.ENDC}")
    print(" â€¢ Improve your security posture")
    print(" â€¢ NOT damage your system")
    print(" â€¢ Be fully logged for audit")
   
    while True:
        response = input(f"\n{Colors.BOLD}{Colors.OKGREEN}Do you grant permission? (yes/no/info): {Colors.ENDC}").strip().lower()
        if response in ['yes', 'y']:
            scanner.consent_given[action] = True
            print(f"{Colors.OKGREEN}âœ“ Permission granted{Colors.ENDC}")
            return True
        elif response in ['no', 'n']:
            scanner.consent_given[action] = False
            print(f"{Colors.WARNING}âœ— Permission denied - Skipping this action{Colors.ENDC}")
            return False
        elif response == 'info':
            print(f"\n{Colors.OKCYAN}Additional Information:{Colors.ENDC}")
            print(" â€¢ This tool follows industry best practices")
            print(" â€¢ All actions are reversible")
            print(" â€¢ Backups are created automatically")
            print(" â€¢ You can stop at any time with Ctrl+C")
        else:
            print(f"{Colors.FAIL}Invalid input. Please enter 'yes', 'no', or 'info'{Colors.ENDC}")

def safe_execute(func, action_name, *args, **kwargs):
    """Ensures nothing fails and no damage occurs"""
    try:
        print(f"\n{Colors.OKCYAN}[SAFE MODE] Preparing to execute: {action_name}{Colors.ENDC}")
       
        # Extract requires_root if present
        requires_root = kwargs.pop('requires_root', True)
       
        # Pre-execution check
        if not is_root() and requires_root:
            print(f"{Colors.WARNING}[SAFE MODE] Root required but not available - Operation skipped safely{Colors.ENDC}")
            return False
       
        # Execute with error handling
        result = func(*args, **kwargs)
       
        print(f"{Colors.OKGREEN}[SAFE MODE] âœ“ Operation completed safely{Colors.ENDC}")
        return result
       
    except KeyboardInterrupt:
        print(f"\n{Colors.WARNING}[SAFE MODE] Operation interrupted by user - System state preserved{Colors.ENDC}")
        return False
    except Exception as e:
        print(f"{Colors.FAIL}[SAFE MODE] Error caught and handled: {str(e)}{Colors.ENDC}")
        print(f"{Colors.OKGREEN}[SAFE MODE] System remains stable{Colors.ENDC}")
        return False

# ==================== FEATURE: NETWORK DEVICE DISCOVERY ====================
def discover_network_devices():
    """Scans network for all active devices"""
    print(f"\n{Colors.HEADER}{'='*70}{Colors.ENDC}")
    print(f"{Colors.BOLD}ğŸŒ NETWORK DEVICE DISCOVERY & MAPPING{Colors.ENDC}")
    print(f"{Colors.HEADER}{'='*70}{Colors.ENDC}\n")
   
    print(f"{Colors.OKCYAN}[*] Detecting network configuration...{Colors.ENDC}")
   
    # Get local IP and network range
    success, output, _ = run_command("ip -4 addr show | grep inet | awk '{print $2}'")
    if not success:
        print(f"{Colors.FAIL}[!] Could not detect network{Colors.ENDC}")
        return []
   
    networks = []
    for line in output.split('\n'):
        if '/' in line and not line.startswith('127.'):
            networks.append(line.strip())
   
    if not networks:
        print(f"{Colors.WARNING}[!] No suitable network found{Colors.ENDC}")
        return []
   
    network = networks[0]
    base_ip = '.'.join(network.split('.')[:-1]).split('/')[0]
   
    print(f"{Colors.OKGREEN}[+] Network detected: {network}{Colors.ENDC}")
    print(f"{Colors.OKCYAN}[*] Scanning network range: {base_ip}.0/24{Colors.ENDC}")
    print(f"{Colors.OKCYAN}[*] This may take 1-2 minutes...{Colors.ENDC}\n")
   
    active_devices = []
   
    # Fast ping sweep
    with ThreadPoolExecutor(max_workers=50) as executor:
        futures = {}
        for i in range(1, 255):
            ip = f"{base_ip}.{i}"
            futures[executor.submit(ping_host, ip)] = ip
       
        completed = 0
        for future in as_completed(futures):
            completed += 1
            if completed % 50 == 0:
                print(f"{Colors.OKCYAN}[*] Progress: {completed}/254 IPs scanned{Colors.ENDC}", end='\r')
           
            ip = futures[future]
            if future.result():
                # Get MAC address
                mac = get_mac_address(ip)
                vendor = identify_vendor(mac) if mac else "Unknown"
                active_devices.append({'ip': ip, 'mac': mac, 'vendor': vendor})
   
    print(f"\n{Colors.OKGREEN}[+] Found {len(active_devices)} active devices{Colors.ENDC}\n")
   
    # Display devices
    if active_devices:
        print(f"{Colors.BOLD}{'IP Address':<20} {'MAC Address':<20} {'Vendor':<30}{Colors.ENDC}")
        print(f"{Colors.HEADER}{'-'*70}{Colors.ENDC}")
        for device in active_devices:
            print(f"{device['ip']:<20} {device['mac'] or 'N/A':<20} {device['vendor']:<30}")
            scanner.network_devices.append(device)
   
    return active_devices

def ping_host(ip):
    """Fast ping check"""
    result = subprocess.run(f"ping -c 1 -W 1 {ip} > /dev/null 2>&1", shell=True)
    return result.returncode == 0

def get_mac_address(ip):
    """Get MAC address for an IP"""
    success, output, _ = run_command(f"arp -n {ip} 2>/dev/null | grep '{ip}' | awk '{{print $3}}'")
    if success and output.strip() and ':' in output:
        return output.strip()
    return None

def identify_vendor(mac):
    """Identify device vendor from MAC address"""
    if not mac or len(mac) < 8:
        return "Unknown"
   
    # OUI database (simplified)
    oui_database = {
        '00:50:56': 'VMware',
        '00:0c:29': 'VMware',
        '08:00:27': 'VirtualBox',
        'dc:a6:32': 'Raspberry Pi',
        'b8:27:eb': 'Raspberry Pi',
        '00:1b:63': 'Apple',
        '00:1e:c2': 'Apple',
        'f8:ff:c2': 'Apple'
    }
   
    oui = mac[:8].lower()
    return oui_database.get(oui, "Unknown Vendor")

# ==================== FEATURE: INTRUSION DETECTION ====================
def detect_suspicious_activity(devices):
    """Advanced intrusion detection - finds suspicious devices"""
    print(f"\n{Colors.HEADER}{'='*70}{Colors.ENDC}")
    print(f"{Colors.BOLD}ğŸ” INTRUSION DETECTION & THREAT ANALYSIS{Colors.ENDC}")
    print(f"{Colors.HEADER}{'='*70}{Colors.ENDC}\n")
   
    if not ask_permission("Scan for suspicious network activity",
                         "Analyze devices for intrusion indicators",
                         "MEDIUM"):
        return
   
    print(f"{Colors.OKCYAN}[*] Analyzing {len(devices)} devices for threats...{Colors.ENDC}\n")
   
    suspicious_found = []
   
    for device in devices:
        ip = device['ip']
        mac = device['mac']
       
        # Check 1: Scan for open suspicious ports
        suspicious_ports = scan_device_ports(ip)
       
        # Check 2: Check if device is performing port scanning
        if is_port_scanning(ip):
            scanner.log_suspicious_device(ip, mac, "Device is performing port scan", "HIGH")
            suspicious_found.append((ip, "PORT SCANNING", "HIGH"))
       
        # Check 3: Unusual MAC address patterns
        if mac and is_spoofed_mac(mac):
            scanner.log_suspicious_device(ip, mac, "Spoofed/randomized MAC address", "MEDIUM")
            suspicious_found.append((ip, "SPOOFED MAC", "MEDIUM"))
       
        # Check 4: Multiple open high-risk ports
        if len(suspicious_ports) >= 3:
            scanner.log_suspicious_device(ip, mac, f"{len(suspicious_ports)} suspicious ports open", "HIGH")
            suspicious_found.append((ip, f"{len(suspicious_ports)} SUSPICIOUS PORTS", "HIGH"))
       
        # Check 5: Check for running attack tools
        if has_attack_tools(ip):
            scanner.log_suspicious_device(ip, mac, "Running penetration testing tools", "CRITICAL")
            suspicious_found.append((ip, "ATTACK TOOLS DETECTED", "CRITICAL"))
   
    if suspicious_found:
        print(f"{Colors.FAIL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Colors.ENDC}")
        print(f"{Colors.FAIL}â•‘ âš ï¸ SUSPICIOUS DEVICES DETECTED - POTENTIAL INTRUDERS     â•‘{Colors.ENDC}")
        print(f"{Colors.FAIL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.ENDC}\n")
       
        for ip, reason, threat in suspicious_found:
            threat_color = Colors.FAIL if threat in ["HIGH", "CRITICAL"] else Colors.WARNING
            print(f"{threat_color}[{threat}] {ip:<15} - {reason}{Colors.ENDC}")
       
        print(f"\n{Colors.BOLD}Recommended Actions:{Colors.ENDC}")
        print(" 1. Investigate these devices immediately")
        print(" 2. Check if they are authorized")
        print(" 3. Consider blocking at firewall level")
        print(" 4. Review access logs")
       
        if ask_permission("Block suspicious devices with firewall",
                         f"Add {len(suspicious_found)} devices to firewall blacklist",
                         "HIGH"):
            block_suspicious_devices(suspicious_found)
    else:
        print(f"{Colors.OKGREEN}[âœ“] No suspicious devices detected - Network appears clean{Colors.ENDC}")

def scan_device_ports(ip):
    """Scan a device for commonly exploited ports"""
    suspicious_ports = []
    dangerous_ports = [23, 445, 1433, 3389, 5900, 6379, 27017]
   
    for port in dangerous_ports:
        if scan_port(ip, port, timeout=0.5):
            suspicious_ports.append(port)
   
    return suspicious_ports

def is_port_scanning(ip):
    """Detect if device is performing port scanning"""
    # Check recent connections in logs
    success, output, _ = run_command(f"grep '{ip}' /var/log/syslog 2>/dev/null | grep -i 'SYN' | wc -l")
    if success and output.strip():
        syn_count = int(output.strip())
        return syn_count > 50 # More than 50 SYN packets = likely scanning
    return False

def is_spoofed_mac(mac):
    """Check if MAC address appears spoofed"""
    if not mac:
        return False
    # Check for locally administered bit (2nd hex digit is 2, 6, A, or E)
    second_char = mac[1].lower()
    return second_char in ['2', '6', 'a', 'e']

def has_attack_tools(ip):
    """Check if device is running known attack tools"""
    # This would require deeper packet inspection
    # Simplified check for now
    return False

def block_suspicious_devices(suspicious_list):
    """Block suspicious devices with firewall"""
    if not is_root():
        print(f"{Colors.WARNING}[!] Root required to block devices{Colors.ENDC}")
        return
   
    print(f"\n{Colors.OKCYAN}[*] Blocking suspicious devices...{Colors.ENDC}\n")
   
    for ip, reason, threat in suspicious_list:
        print(f"{Colors.OKCYAN}[*] Blocking {ip}...{Colors.ENDC}")
        success, _, _ = run_command(f"ufw deny from {ip}")
        if success:
            print(f"{Colors.OKGREEN}[âœ“] Blocked {ip}{Colors.ENDC}")
            scanner.log_patch(f"Blocked suspicious device {ip}", True, reason)
        else:
            print(f"{Colors.FAIL}[!] Failed to block {ip}{Colors.ENDC}")
            scanner.log_patch(f"Block device {ip}", False, reason)

# ==================== EXISTING FEATURES (ENHANCED) ====================
def scan_port(host, port, timeout=1):
    """Perfect port scanning implementation"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except:
        return False

def scan_and_patch_vulnerabilities():
    """Main vulnerability scanning"""
    print(f"\n{Colors.HEADER}{'='*70}{Colors.ENDC}")
    print(f"{Colors.BOLD}ğŸ”’ VULNERABILITY SCANNING & PATCHING{Colors.ENDC}")
    print(f"{Colors.HEADER}{'='*70}{Colors.ENDC}\n")
   
    if not ask_permission("Scan localhost for vulnerabilities",
                         "Check for open ports and security issues",
                         "LOW"):
        return
   
    print(f"{Colors.OKCYAN}[*] Scanning localhost for vulnerabilities...{Colors.ENDC}\n")
   
    open_ports = []
    for port in PORT_DATABASE.keys():
        if scan_port("127.0.0.1", port):
            open_ports.append(port)
   
    vulnerable_ports = []
    for port in open_ports:
        info = PORT_DATABASE[port]
        if not info['necessary']:
            vulnerable_ports.append((port, info))
            scanner.log_vulnerability('Open Port', f"Port {port} ({info['service']}) is exposed", info['risk'], f"Port {port}")
   
    if vulnerable_ports:
        print(f"{Colors.FAIL}[!] FOUND {len(vulnerable_ports)} VULNERABLE PORTS:{Colors.ENDC}\n")
       
        for port, info in vulnerable_ports:
            risk_color = Colors.FAIL if info['risk'] in ['HIGH', 'CRITICAL'] else Colors.WARNING
            print(f"{risk_color}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Colors.ENDC}")
            print(f"{risk_color} Port {port} - {info['service']} [{info['risk']} RISK]{Colors.ENDC}")
            print(f"{risk_color}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.ENDC}")
            print(f" Reason: {info['reason']}")
            if info['cve']:
                print(f" Known Vulnerability: {info['cve']}")
            print()
       
        if ask_permission(f"Patch all {len(vulnerable_ports)} vulnerabilities",
                         "Close unnecessary ports and stop services",
                         "HIGH"):
            patch_vulnerable_ports(vulnerable_ports)
    else:
        print(f"{Colors.OKGREEN}[âœ“] No vulnerable ports found{Colors.ENDC}")

def patch_vulnerable_ports(vulnerable_ports):
    """Patch vulnerable ports safely"""
    print(f"\n{Colors.OKCYAN}[*] PATCHING VULNERABILITIES...{Colors.ENDC}\n")
   
    for port, info in vulnerable_ports:
        if not ask_permission(f"Close port {port} ({info['service']})",
                             f"Risk: {info['risk']} - {info['reason']}",
                             info['risk']):
            continue
       
        print(f"{Colors.OKCYAN}[*] Patching port {port}...{Colors.ENDC}")
       
        # Stop services
        for service in info['services']:
            run_command(f"systemctl stop {service} 2>/dev/null")
            run_command(f"systemctl disable {service} 2>/dev/null")
       
        # Kill processes on port
        success, output, _ = run_command(f"lsof -ti :{port}")
        if success and output.strip():
            for pid in output.strip().split('\n'):
                if pid.isdigit():
                    run_command(f"kill -9 {pid}")
       
        # Block with firewall
        run_command(f"ufw deny {port} 2>/dev/null")
       
        time.sleep(1)
       
        if not scan_port("127.0.0.1", port):
            print(f"{Colors.OKGREEN}[âœ“] Port {port} secured{Colors.ENDC}")
            scanner.log_patch(f"Closed port {port} ({info['service']})", True)
        else:
            print(f"{Colors.WARNING}[!] Port {port} may still be open{Colors.ENDC}")
            scanner.log_patch(f"Close port {port}", False)

def generate_final_report():
    """Generate beautiful final report"""
    print(f"\n{Colors.HEADER}{'='*70}{Colors.ENDC}")
    print(f"{Colors.BOLD}ğŸ“Š SECURITY SCAN COMPLETE - FINAL REPORT{Colors.ENDC}")
    print(f"{Colors.HEADER}{'='*70}{Colors.ENDC}\n")
   
    # Summary
    print(f"{Colors.BOLD}SUMMARY:{Colors.ENDC}")
    print(f" ğŸ” Vulnerabilities Found: {Colors.FAIL}{len(scanner.vulnerabilities)}{Colors.ENDC}")
    print(f" âœ… Patches Applied: {Colors.OKGREEN}{len(scanner.patches_applied)}{Colors.ENDC}")
    print(f" âŒ Patches Failed: {Colors.WARNING}{len(scanner.patches_failed)}{Colors.ENDC}")
    print(f" ğŸ‘¥ Network Devices: {Colors.OKCYAN}{len(scanner.network_devices)}{Colors.ENDC}")
    print(f" âš ï¸ Suspicious Devices: {Colors.FAIL}{len(scanner.suspicious_devices)}{Colors.ENDC}\n")
   
    # Save JSON report
    report_data = {
        'scan_time': datetime.now().isoformat(),
        'vulnerabilities': scanner.vulnerabilities,
        'patches_applied': scanner.patches_applied,
        'patches_failed': scanner.patches_failed,
        'network_devices': scanner.network_devices,
        'suspicious_devices': scanner.suspicious_devices,
        'consent_log': scanner.consent_given
    }
   
    with open(scanner.report_file, 'w') as f:
        json.dump(report_data, f, indent=2)
   
    print(f"{Colors.OKGREEN}[âœ“] Detailed report saved: {scanner.report_file}{Colors.ENDC}\n")
   
    print(f"{Colors.BOLD}SECURITY RECOMMENDATIONS:{Colors.ENDC}")
    print(" 1. Run this tool weekly")
    print(" 2. Monitor suspicious devices closely")
    print(" 3. Keep all software updated")
    print(" 4. Review the JSON report for details")
    print(" 5. Enable automatic security updates")
    print()

def main():
    """Main program"""
    print_banner()
   
    print(f"{Colors.BOLD}Welcome to the Ultimate Security Tool!{Colors.ENDC}\n")
    print("This tool was designed by three expert contestants:")
    print(f" {Colors.OKGREEN}âœ“ Contestant 1:{Colors.ENDC} Always asks permission (respectful)")
    print(f" {Colors.OKGREEN}âœ“ Contestant 2:{Colors.ENDC} Makes everything work perfectly (technical)")
    print(f" {Colors.OKGREEN}âœ“ Contestant 3:{Colors.ENDC} Ensures no damage occurs (safe)")
    print()
   
    if not is_root():
        print(f"{Colors.WARNING}âš ï¸ NOT running as root{Colors.ENDC}")
        print(f"{Colors.WARNING} Some features will be limited{Colors.ENDC}")
        print(f"{Colors.OKCYAN} Run with: sudo python3 {sys.argv[0]}{Colors.ENDC}\n")
   
    if not ask_permission("Start comprehensive security scan",
                         "Scan vulnerabilities, network devices, and intrusions",
                         "LOW"):
        print(f"\n{Colors.WARNING}Scan cancelled by user{Colors.ENDC}")
        sys.exit(0)
   
    try:
        # Feature 1: Network Discovery (no root needed)
        devices = safe_execute(discover_network_devices, "Network Device Discovery", requires_root=False)
        if devices is False:
            devices = []
       
        # Feature 2: Intrusion Detection
        if devices:
            safe_execute(detect_suspicious_activity, "Intrusion Detection", devices)
       
        # Feature 3: Vulnerability Scanning (requires root)
        safe_execute(scan_and_patch_vulnerabilities, "Vulnerability Scanning", requires_root=True)
       
        # Final Report
        generate_final_report()
       
        print(f"{Colors.OKGREEN}{Colors.BOLD}")
        print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print("â•‘                                                       â•‘")
        print("â•‘                 âœ… SECURITY SCAN COMPLETE              â•‘")
        print("â•‘              ğŸ›¡ï¸ YOUR NETWORK IS NOW MORE SECURE       â•‘")
        print("â•‘                                                       â•‘")
        print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"{Colors.ENDC}")
       
    except KeyboardInterrupt:
        print(f"\n\n{Colors.WARNING}âš ï¸ Scan interrupted by user{Colors.ENDC}")
        generate_final_report()
        print(f"{Colors.OKGREEN}System state preserved - No damage occurred{Colors.ENDC}")

if __name__ == "__main__":
    main()
