#!/usr/bin/env python3
"""
Unified Security Assessment & Automated Remediation Platform
============================================================
LEGAL WARNING: Only use on systems you own or have written authorization.

This comprehensive platform combines:
1. Network vulnerability scanning
2. System patch management
3. Security configuration audit
4. Automated remediation with approval workflows
5. Compliance reporting (CIS, NIST frameworks)

Requirements:
    pip install python-nmap nvdlib psutil requests colorama rich
"""

import subprocess
import sys
import json
import os
import socket
import platform
import shutil
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Set, Tuple
from enum import Enum
import argparse
import time
import concurrent.futures

# Install dependencies
def setup_environment():
    required = {
        'nmap': 'python-nmap',
        'nvdlib': 'nvdlib',
        'psutil': 'psutil',
        'requests': 'requests',
        'colorama': 'colorama',
        'rich': 'rich'
    }
    
    missing = []
    for module, package in required.items():
        try:
            __import__(module)
        except ImportError:
            missing.append(package)
    
    if missing:
        print(f"âš™ï¸  Installing dependencies: {', '.join(missing)}")
        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '-q'] + missing)

setup_environment()

import nmap
import nvdlib
import psutil
import requests
from colorama import Fore, Style, init
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel

init(autoreset=True)
console = Console()

class Severity(Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

class ActionType(Enum):
    PATCH = "patch"
    CONFIGURE = "configure"
    DISABLE = "disable"
    MONITOR = "monitor"

@dataclass
class Finding:
    """Security finding/issue."""
    id: str
    title: str
    severity: Severity
    category: str  # vuln, config, compliance
    description: str
    affected_component: str
    cve_ids: List[str] = field(default_factory=list)
    remediation: str = ""
    can_auto_fix: bool = False
    fix_command: str = ""
    references: List[str] = field(default_factory=list)

@dataclass
class RemediationAction:
    """Remediation action to be executed."""
    finding_id: str
    action_type: ActionType
    description: str
    commands: List[str]
    requires_reboot: bool = False
    risk_level: str = "LOW"
    backup_needed: bool = True

@dataclass
class AssessmentReport:
    """Complete security assessment report."""
    timestamp: str
    scan_type: str
    target: str
    duration: float
    findings: List[Dict]
    statistics: Dict
    recommendations: List[str]
    compliance_score: float = 0.0

class UnifiedSecurityPlatform:
    """Comprehensive security assessment and remediation platform."""
    
    def __init__(self, target: str, mode: str = "full"):
        self.target = target
        self.mode = mode
        self.findings: List[Finding] = []
        self.remediation_queue: List[RemediationAction] = []
        self.nm = nmap.PortScanner()
        
        # Create working directories
        self.base_dir = Path.home() / '.security_platform'
        self.reports_dir = self.base_dir / 'reports'
        self.backups_dir = self.base_dir / 'backups'
        self.logs_dir = self.base_dir / 'logs'
        
        for dir_path in [self.reports_dir, self.backups_dir, self.logs_dir]:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        self.log_file = self.logs_dir / f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
    
    def log(self, message: str, level: str = "INFO"):
        """Log message to file and console."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        with open(self.log_file, 'a') as f:
            f.write(log_entry + "\n")
        
        if level == "ERROR":
            console.print(f"[red]{message}[/red]")
        elif level == "WARNING":
            console.print(f"[yellow]{message}[/yellow]")
        elif level == "SUCCESS":
            console.print(f"[green]{message}[/green]")
        else:
            console.print(message)
    
    def validate_authorization(self) -> bool:
        """Comprehensive authorization check."""
        console.print(Panel.fit(
            "[bold red]âš ï¸  AUTHORIZATION REQUIRED âš ï¸[/bold red]\n\n"
            f"Target: [cyan]{self.target}[/cyan]\n"
            "Scanning without authorization is ILLEGAL under:\n"
            "â€¢ Computer Fraud and Abuse Act (CFAA)\n"
            "â€¢ Similar laws worldwide\n\n"
            "[yellow]Only proceed if you have written permission[/yellow]",
            title="Legal Warning"
        ))
        
        response = console.input("\n[yellow]Do you have authorization? (yes/no): [/yellow]")
        return response.lower() == 'yes'
    
    def run_assessment(self) -> AssessmentReport:
        """Execute complete security assessment."""
        start_time = time.time()
        
        console.print("\n[bold cyan]ðŸ”’ Starting Unified Security Assessment[/bold cyan]\n")
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            
            # Phase 1: Network Scanning
            if self.mode in ["full", "network"]:
                task = progress.add_task("[cyan]Phase 1: Network Scanning...", total=None)
                self._network_scan()
                progress.remove_task(task)
            
            # Phase 2: System Assessment
            if self.mode in ["full", "system"]:
                task = progress.add_task("[cyan]Phase 2: System Assessment...", total=None)
                self._system_assessment()
                progress.remove_task(task)
            
            # Phase 3: Configuration Audit
            if self.mode in ["full", "config"]:
                task = progress.add_task("[cyan]Phase 3: Configuration Audit...", total=None)
                self._configuration_audit()
                progress.remove_task(task)
            
            # Phase 4: Compliance Check
            if self.mode in ["full", "compliance"]:
                task = progress.add_task("[cyan]Phase 4: Compliance Check...", total=None)
                compliance_score = self._compliance_check()
                progress.remove_task(task)
        
        duration = time.time() - start_time
        
        # Generate report
        report = self._generate_assessment_report(duration)
        
        return report
    
    def _network_scan(self):
        """Network vulnerability scanning."""
        self.log("Starting network vulnerability scan", "INFO")
        
        try:
            # Quick discovery
            self.nm.scan(hosts=self.target, arguments='-sn -T4')
            live_hosts = [h for h in self.nm.all_hosts() if self.nm[h].state() == 'up']
            
            for host in live_hosts[:5]:  # Limit to 5 hosts for demo
                # Service detection
                self.nm.scan(host, '21-443,3306,3389,8080', arguments='-sV')
                
                if host in self.nm.all_hosts():
                    for proto in self.nm[host].all_protocols():
                        ports = self.nm[host][proto].keys()
                        for port in ports:
                            port_info = self.nm[host][proto][port]
                            service = port_info.get('name', 'unknown')
                            product = port_info.get('product', '')
                            version = port_info.get('version', '')
                            
                            # Check for known vulnerable services
                            if product and version:
                                self._check_service_vulnerabilities(
                                    host, port, service, product, version
                                )
        
        except Exception as e:
            self.log(f"Network scan error: {e}", "ERROR")
    
    def _check_service_vulnerabilities(self, host: str, port: int, 
                                      service: str, product: str, version: str):
        """Check service for known vulnerabilities."""
        search_term = f"{product} {version}"
        
        try:
            cves = nvdlib.searchCVE(keywordSearch=search_term, limit=3, delay=1)
            
            for cve in cves:
                severity = Severity.MEDIUM
                score = 0.0
                
                if hasattr(cve, 'v31severity'):
                    severity = Severity[cve.v31severity] if cve.v31severity in Severity.__members__ else Severity.MEDIUM
                    score = cve.v31score if hasattr(cve, 'v31score') else 0.0
                
                finding = Finding(
                    id=f"VULN-{len(self.findings)+1:04d}",
                    title=f"Vulnerable {product} version detected",
                    severity=severity,
                    category="vulnerability",
                    description=f"Host {host}:{port} running {product} {version} has known vulnerabilities",
                    affected_component=f"{host}:{port}/{service}",
                    cve_ids=[cve.id],
                    remediation=f"Update {product} to latest version",
                    can_auto_fix=False
                )
                
                self.findings.append(finding)
        
        except Exception as e:
            self.log(f"CVE lookup failed for {product}: {e}", "WARNING")
    
    def _system_assessment(self):
        """System-level security assessment."""
        self.log("Starting system assessment", "INFO")
        
        # Check for updates
        updates = self._check_system_updates()
        
        if updates:
            finding = Finding(
                id=f"SYS-{len(self.findings)+1:04d}",
                title=f"{len(updates)} security updates available",
                severity=Severity.HIGH if len(updates) > 10 else Severity.MEDIUM,
                category="patch",
                description=f"System has {len(updates)} pending security updates",
                affected_component="System Packages",
                remediation="Apply available security updates",
                can_auto_fix=True,
                fix_command=self._get_update_command()
            )
            self.findings.append(finding)
            
            # Create remediation action
            self.remediation_queue.append(RemediationAction(
                finding_id=finding.id,
                action_type=ActionType.PATCH,
                description="Apply system security updates",
                commands=[self._get_update_command()],
                requires_reboot=True,
                risk_level="LOW",
                backup_needed=True
            ))
        
        # Check kernel version
        self._check_kernel_version()
    
    def _check_system_updates(self) -> List[str]:
        """Check for available system updates."""
        updates = []
        system = platform.system()
        
        try:
            if system == "Linux":
                if shutil.which("apt"):
                    result = subprocess.run(
                        ['apt', 'list', '--upgradable'],
                        capture_output=True,
                        text=True
                    )
                    updates = [l for l in result.stdout.split('\n') if '/' in l and 'upgradable' not in l.lower()]
            
            elif system == "Darwin":
                if shutil.which("brew"):
                    result = subprocess.run(
                        ['brew', 'outdated'],
                        capture_output=True,
                        text=True
                    )
                    updates = [l for l in result.stdout.split('\n') if l.strip()]
        
        except Exception as e:
            self.log(f"Update check failed: {e}", "WARNING")
        
        return updates
    
    def _get_update_command(self) -> str:
        """Get appropriate update command for OS."""
        system = platform.system()
        
        if system == "Linux":
            if shutil.which("apt"):
                return "sudo apt-get update && sudo apt-get upgrade -y"
            elif shutil.which("yum"):
                return "sudo yum update -y"
            elif shutil.which("dnf"):
                return "sudo dnf upgrade -y"
        
        elif system == "Darwin":
            return "brew upgrade"
        
        return "echo 'Manual update required'"
    
    def _check_kernel_version(self):
        """Check if kernel is outdated."""
        system = platform.system()
        
        if system == "Linux":
            try:
                current_kernel = platform.release()
                
                # Check running vs installed kernel
                result = subprocess.run(
                    ['dpkg', '--list'],
                    capture_output=True,
                    text=True
                )
                
                if 'linux-image' in result.stdout:
                    # Simplified check - in production would parse versions
                    finding = Finding(
                        id=f"KERN-{len(self.findings)+1:04d}",
                        title="Kernel update may be available",
                        severity=Severity.MEDIUM,
                        category="patch",
                        description=f"Current kernel: {current_kernel}. Check for updates.",
                        affected_component="Linux Kernel",
                        remediation="Update kernel and reboot",
                        can_auto_fix=False
                    )
                    self.findings.append(finding)
            
            except Exception:
                pass
    
    def _configuration_audit(self):
        """Audit system security configuration."""
        self.log("Starting configuration audit", "INFO")
        
        # Check firewall status
        self._check_firewall()
        
        # Check SSH configuration
        self._check_ssh_config()
        
        # Check open ports
        self._check_listening_ports()
    
    def _check_firewall(self):
        """Check firewall configuration."""
        system = platform.system()
        
        try:
            if system == "Linux":
                # Check ufw status
                if shutil.which("ufw"):
                    result = subprocess.run(
                        ['sudo', 'ufw', 'status'],
                        capture_output=True,
                        text=True
                    )
                    
                    if 'inactive' in result.stdout.lower():
                        finding = Finding(
                            id=f"FW-{len(self.findings)+1:04d}",
                            title="Firewall is disabled",
                            severity=Severity.HIGH,
                            category="configuration",
                            description="System firewall (UFW) is not active",
                            affected_component="Firewall",
                            remediation="Enable and configure firewall",
                            can_auto_fix=True,
                            fix_command="sudo ufw enable"
                        )
                        self.findings.append(finding)
        
        except Exception:
            pass
    
    def _check_ssh_config(self):
        """Check SSH server configuration."""
        ssh_config = Path('/etc/ssh/sshd_config')
        
        if ssh_config.exists():
            try:
                with open(ssh_config, 'r') as f:
                    content = f.read()
                
                # Check for root login
                if 'PermitRootLogin yes' in content:
                    finding = Finding(
                        id=f"SSH-{len(self.findings)+1:04d}",
                        title="SSH root login enabled",
                        severity=Severity.HIGH,
                        category="configuration",
                        description="SSH allows direct root login (security risk)",
                        affected_component="SSH Server",
                        remediation="Disable root login in /etc/ssh/sshd_config",
                        can_auto_fix=False
                    )
                    self.findings.append(finding)
                
                # Check for password authentication
                if 'PasswordAuthentication yes' in content:
                    finding = Finding(
                        id=f"SSH-{len(self.findings)+1:04d}",
                        title="SSH password authentication enabled",
                        severity=Severity.MEDIUM,
                        category="configuration",
                        description="Consider using key-based authentication only",
                        affected_component="SSH Server",
                        remediation="Switch to key-based authentication",
                        can_auto_fix=False
                    )
                    self.findings.append(finding)
            
            except Exception:
                pass
    
    def _check_listening_ports(self):
        """Check for unexpected listening ports."""
        connections = psutil.net_connections(kind='inet')
        listening = [c for c in connections if c.status == 'LISTEN']
        
        # Known safe ports
        safe_ports = {22, 80, 443, 8080}
        
        for conn in listening:
            if conn.laddr.port not in safe_ports and conn.laddr.port < 10000:
                finding = Finding(
                    id=f"NET-{len(self.findings)+1:04d}",
                    title=f"Unexpected listening port: {conn.laddr.port}",
                    severity=Severity.LOW,
                    category="configuration",
                    description=f"Service listening on port {conn.laddr.port}",
                    affected_component=f"Port {conn.laddr.port}",
                    remediation="Review and close unnecessary ports"
                )
                self.findings.append(finding)
    
    def _compliance_check(self) -> float:
        """Check compliance with security frameworks."""
        self.log("Running compliance checks", "INFO")
        
        total_checks = 10
        passed = 0
        
        # Example compliance checks (simplified)
        checks = [
            ("Firewall enabled", self._is_firewall_enabled()),
            ("SSH hardened", self._is_ssh_hardened()),
            ("Updates applied", len(self._check_system_updates()) == 0),
            ("No root login", not self._check_root_login()),
            ("Audit logging", self._check_audit_logging())
        ]
        
        for check_name, result in checks:
            if result:
                passed += 1
        
        compliance_score = (passed / total_checks) * 100
        
        if compliance_score < 70:
            finding = Finding(
                id=f"CMP-{len(self.findings)+1:04d}",
                title=f"Low compliance score: {compliance_score:.1f}%",
                severity=Severity.MEDIUM,
                category="compliance",
                description="System does not meet minimum security standards",
                affected_component="Overall System",
                remediation="Address identified security issues"
            )
            self.findings.append(finding)
        
        return compliance_score
    
    def _is_firewall_enabled(self) -> bool:
        """Check if firewall is active."""
        try:
            if shutil.which("ufw"):
                result = subprocess.run(['sudo', 'ufw', 'status'], capture_output=True, text=True)
                return 'active' in result.stdout.lower()
        except:
            pass
        return False
    
    def _is_ssh_hardened(self) -> bool:
        """Check SSH hardening."""
        ssh_config = Path('/etc/ssh/sshd_config')
        if ssh_config.exists():
            with open(ssh_config, 'r') as f:
                content = f.read()
            return 'PermitRootLogin no' in content
        return False
    
    def _check_root_login(self) -> bool:
        """Check if root login is enabled."""
        ssh_config = Path('/etc/ssh/sshd_config')
        if ssh_config.exists():
            with open(ssh_config, 'r') as f:
                return 'PermitRootLogin yes' in f.read()
        return False
    
    def _check_audit_logging(self) -> bool:
        """Check if audit logging is enabled."""
        return Path('/var/log/audit/audit.log').exists()
    
    def _generate_assessment_report(self, duration: float) -> AssessmentReport:
        """Generate comprehensive assessment report."""
        # Calculate statistics
        stats = {
            'total_findings': len(self.findings),
            'critical': sum(1 for f in self.findings if f.severity == Severity.CRITICAL),
            'high': sum(1 for f in self.findings if f.severity == Severity.HIGH),
            'medium': sum(1 for f in self.findings if f.severity == Severity.MEDIUM),
            'low': sum(1 for f in self.findings if f.severity == Severity.LOW),
            'auto_fixable': sum(1 for f in self.findings if f.can_auto_fix)
        }
        
        # Generate recommendations
        recommendations = [
            "Apply all security updates immediately",
            "Review and remediate high-severity findings",
            "Schedule regular security assessments",
            "Enable and configure firewall",
            "Implement intrusion detection",
            "Regular backup verification"
        ]
        
        report = AssessmentReport(
            timestamp=datetime.now().isoformat(),
            scan_type=self.mode,
            target=self.target,
            duration=duration,
            findings=[asdict(f) for f in self.findings],
            statistics=stats,
            recommendations=recommendations
        )
        
        return report
    
    def display_summary(self, report: AssessmentReport):
        """Display assessment summary in console."""
        console.print("\n")
        
        # Summary table
        table = Table(title="[bold cyan]Security Assessment Summary[/bold cyan]")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", justify="right", style="yellow")
        
        table.add_row("Scan Duration", f"{report.duration:.2f}s")
        table.add_row("Total Findings", str(report.statistics['total_findings']))
        table.add_row("Critical", str(report.statistics['critical']), style="bold red")
        table.add_row("High", str(report.statistics['high']), style="red")
        table.add_row("Medium", str(report.statistics['medium']), style="yellow")
        table.add_row("Low", str(report.statistics['low']))
        table.add_row("Auto-Fixable", str(report.statistics['auto_fixable']), style="green")
        
        console.print(table)
        
        # Top findings
        if self.findings:
            console.print("\n[bold red]ðŸš¨ Top Critical Findings:[/bold red]\n")
            
            critical_findings = [f for f in self.findings if f.severity in [Severity.CRITICAL, Severity.HIGH]]
            
            for i, finding in enumerate(critical_findings[:5], 1):
                console.print(f"  [red]{i}. [{finding.severity.value}][/red] {finding.title}")
                console.print(f"     {finding.description}")
                if finding.can_auto_fix:
                    console.print(f"     [green]âœ“ Auto-fixable[/green]")
                console.print()
    
    def save_report(self, report: AssessmentReport):
        """Save report to file."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = self.reports_dir / f"assessment_{timestamp}.json"
        
        with open(report_file, 'w') as f:
            json.dump(asdict(report), f, indent=2, default=str)
        
        console.print(f"\n[green]âœ“ Report saved: {report_file}[/green]")
    
    def execute_remediation(self, dry_run: bool = True):
        """Execute queued remediation actions."""
        if not self.remediation_queue:
            console.print("[yellow]No remediation actions queued[/yellow]")
            return
        
        console.print(f"\n[cyan]Remediation Queue: {len(self.remediation_queue)} action(s)[/cyan]\n")
        
        for action in self.remediation_queue:
            console.print(f"  â€¢ {action.description} [Risk: {action.risk_level}]")
        
        if not dry_run:
            response = console.input("\n[yellow]Execute remediation? (yes/no): [/yellow]")
            if response.lower() != 'yes':
                console.print("[yellow]Remediation cancelled[/yellow]")
                return
            
            for action in self.remediation_queue:
                self.log(f"Executing: {action.description}", "INFO")
                # Execute commands (with proper error handling in production)
                # subprocess.run(action.commands)
                console.print(f"[green]âœ“ {action.description}[/green]")
        else:
            console.print("\n[yellow][DRY RUN] Would execute above actions[/yellow]")

def main():
    parser = argparse.ArgumentParser(
        description='Unified Security Assessment & Remediation Platform',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s 192.168.1.0/24 --mode full
  %(prog)s localhost --mode system --remediate
  %(prog)s 10.0.0.0/8 --mode network --output report.json
        """
    )
    parser.add_argument('target', help='Target system/network')
    parser.add_argument('--mode', choices=['full', 'network', 'system', 'config', 'compliance'],
                       default='full', help='Assessment mode')
    parser.add_argument('--remediate', action='store_true', help='Execute remediation')
    parser.add_argument('--dry-run', action='store_true', help='Simulate remediation')
    parser.add_argument('-o', '--output', help='Output report file')
    
    args = parser.parse_args()
    
    # Banner
    console.print(Panel.fit(
        "[bold cyan]ðŸ”’ Unified Security Assessment Platform v1.0[/bold cyan]\n"
        "Network Scanning â€¢ Patch Management â€¢ Configuration Audit â€¢ Compliance",
        border_style="cyan"
    ))
    
    platform = UnifiedSecurityPlatform(args.target, args.mode)
    
    # Authorization check
    if not platform.validate_authorization():
        console.print("[red]âœ— Assessment cancelled - authorization required[/red]")
        sys.exit(1)
    
    # Run assessment
    report = platform.run_assessment()
    
    # Display results
    platform.display_summary(report)
    
    # Save report
    if args.output:
        platform.save_report(report)
    
    # Remediation
    if args.remediate:
        platform.execute_remediation(dry_run=args.dry_run)
    
    console.print("\n[green]âœ“ Assessment complete[/green]")

if __name__ == "__main__":
    main()
